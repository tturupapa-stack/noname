# 화제 종목 수집 방법 설계서

**작성일**: 2025-12-11  
**버전**: 1.0

---

## 1. 개요

### 1.1 목적
"당신이 잠든 사이" 대시보드에서 표시할 화제 종목을 수집하고 선정하는 방법을 정의합니다.

### 1.2 선정 기준
화제 종목은 다음 세 가지 지표를 종합하여 선정합니다:
1. **거래량** (가중치 40%): 평소 대비 거래량 증가율
2. **상승률** (가중치 35%): 전일 대비 가격 상승률
3. **변동폭** (가중치 25%): 당일 고가-저가 차이

### 1.3 수집 주기
- **실시간**: 주가 데이터는 실시간으로 수집 (1분 단위)
- **일일 집계**: 매일 장 마감 후 최종 순위 산정
- **브리핑 생성**: 매일 아침 7시 브리핑 생성

---

## 2. 데이터 수집 구조

### 2.1 데이터 소스

#### 2.1.1 주가 데이터 API
```typescript
// 주가 데이터 인터페이스
interface StockPriceData {
  symbol: string;           // 종목 코드 (예: "TSLA")
  name: string;             // 종목명
  currentPrice: number;     // 현재가
  previousClose: number;    // 전일 종가
  open: number;             // 시가
  high: number;             // 고가
  low: number;              // 저가
  volume: number;           // 거래량
  averageVolume: number;    // 평균 거래량 (20일)
  marketCap: number;        // 시가총액
  sector: string;           // 섹터
  industry: string;         // 산업
  timestamp: string;        // 수집 시각 (ISO 8601)
}
```

#### 2.1.2 거래량 증가율 계산
```typescript
function calculateVolumeIncrease(currentVolume: number, averageVolume: number): number {
  if (averageVolume === 0) return 0;
  return ((currentVolume - averageVolume) / averageVolume) * 100;
}
```

#### 2.1.3 상승률 계산
```typescript
function calculatePriceChange(currentPrice: number, previousClose: number): {
  change: number;
  changePercent: number;
} {
  const change = currentPrice - previousClose;
  const changePercent = (change / previousClose) * 100;
  return { change, changePercent };
}
```

#### 2.1.4 변동폭 계산
```typescript
function calculateVolatility(high: number, low: number, previousClose: number): number {
  const range = high - low;
  return (range / previousClose) * 100; // 변동폭 비율
}
```

---

## 3. 복합 점수 계산

### 3.1 점수 정규화
각 지표를 0-100 점수로 정규화합니다.

```typescript
interface StockMetrics {
  symbol: string;
  volumeIncrease: number;      // 거래량 증가율 (%)
  priceChangePercent: number;  // 상승률 (%)
  volatility: number;           // 변동폭 (%)
}

interface NormalizedScores {
  volumeScore: number;         // 0-100
  priceScore: number;          // 0-100
  volatilityScore: number;     // 0-100
}

function normalizeScores(metrics: StockMetrics): NormalizedScores {
  // 거래량 증가율 정규화 (0% = 0점, 300% 이상 = 100점)
  const volumeScore = Math.min(100, (metrics.volumeIncrease / 3));
  
  // 상승률 정규화 (0% = 0점, 10% 이상 = 100점)
  const priceScore = Math.min(100, (metrics.priceChangePercent / 0.1));
  
  // 변동폭 정규화 (0% = 0점, 5% 이상 = 100점)
  const volatilityScore = Math.min(100, (metrics.volatility / 0.05));
  
  return { volumeScore, priceScore, volatilityScore };
}
```

### 3.2 가중 평균 계산
```typescript
function calculateCompositeScore(scores: NormalizedScores): number {
  const weights = {
    volume: 0.40,      // 거래량 40%
    price: 0.35,       // 상승률 35%
    volatility: 0.25   // 변동폭 25%
  };
  
  return (
    scores.volumeScore * weights.volume +
    scores.priceScore * weights.price +
    scores.volatilityScore * weights.volatility
  );
}
```

### 3.3 전체 계산 함수
```typescript
function calculateStockScore(priceData: StockPriceData): {
  symbol: string;
  compositeScore: number;
  rank: number;
  metrics: StockMetrics;
} {
  // 1. 지표 계산
  const volumeIncrease = calculateVolumeIncrease(
    priceData.volume,
    priceData.averageVolume
  );
  
  const { changePercent } = calculatePriceChange(
    priceData.currentPrice,
    priceData.previousClose
  );
  
  const volatility = calculateVolatility(
    priceData.high,
    priceData.low,
    priceData.previousClose
  );
  
  const metrics: StockMetrics = {
    symbol: priceData.symbol,
    volumeIncrease,
    priceChangePercent: changePercent,
    volatility
  };
  
  // 2. 점수 정규화
  const normalizedScores = normalizeScores(metrics);
  
  // 3. 복합 점수 계산
  const compositeScore = calculateCompositeScore(normalizedScores);
  
  return {
    symbol: priceData.symbol,
    compositeScore: Math.round(compositeScore * 100) / 100, // 소수점 2자리
    rank: 0, // 전체 종목 순위 산정 후 설정
    metrics
  };
}
```

---

## 4. 순위 산정

### 4.1 전체 종목 점수 계산
```typescript
async function calculateAllStockScores(
  stockList: StockPriceData[]
): Promise<Array<{
  symbol: string;
  compositeScore: number;
  rank: number;
  metrics: StockMetrics;
}>> {
  // 모든 종목의 점수 계산
  const scores = stockList.map(priceData => calculateStockScore(priceData));
  
  // 복합 점수 기준 내림차순 정렬
  scores.sort((a, b) => b.compositeScore - a.compositeScore);
  
  // 순위 부여
  scores.forEach((score, index) => {
    score.rank = index + 1;
  });
  
  return scores;
}
```

### 4.2 TOP 3 선정
```typescript
function selectTop3Stocks(
  rankedStocks: Array<{
    symbol: string;
    compositeScore: number;
    rank: number;
  }>
): Stock[] {
  return rankedStocks
    .slice(0, 3)
    .map(stock => ({
      ...stock,
      selectedAt: new Date().toISOString()
    }));
}
```

---

## 5. 데이터 수집 스크립트 예시

### 5.1 Node.js 수집 스크립트
```typescript
// scripts/collectStockData.ts
import axios from 'axios';

interface StockAPIResponse {
  data: StockPriceData[];
  timestamp: string;
}

async function collectStockData(): Promise<StockPriceData[]> {
  try {
    // 실제 API 엔드포인트로 교체 필요
    const response = await axios.get<StockAPIResponse>(
      'https://api.example.com/stocks/realtime',
      {
        headers: {
          'Authorization': `Bearer ${process.env.STOCK_API_KEY}`
        }
      }
    );
    
    return response.data.data;
  } catch (error) {
    console.error('주가 데이터 수집 실패:', error);
    throw error;
  }
}

async function processAndRankStocks(): Promise<Stock[]> {
  // 1. 주가 데이터 수집
  const stockDataList = await collectStockData();
  
  // 2. 복합 점수 계산 및 순위 산정
  const rankedStocks = await calculateAllStockScores(stockDataList);
  
  // 3. TOP 3 선정
  const top3Stocks = selectTop3Stocks(rankedStocks);
  
  return top3Stocks;
}

// 매일 장 마감 후 실행 (예: 오후 4시)
// cron: '0 16 * * 1-5' (월-금 오후 4시)
export async function dailyStockRanking() {
  const topStocks = await processAndRankStocks();
  
  // 데이터베이스에 저장하거나 API로 전송
  await saveTopStocks(topStocks);
  
  return topStocks;
}
```

### 5.2 Python 수집 스크립트 예시
```python
# scripts/collect_stock_data.py
import requests
import json
from datetime import datetime
from typing import List, Dict

def collect_stock_data() -> List[Dict]:
    """주가 데이터 수집"""
    url = "https://api.example.com/stocks/realtime"
    headers = {
        "Authorization": f"Bearer {os.getenv('STOCK_API_KEY')}"
    }
    
    response = requests.get(url, headers=headers)
    response.raise_for_status()
    
    return response.json()['data']

def calculate_volume_increase(current_volume: float, average_volume: float) -> float:
    """거래량 증가율 계산"""
    if average_volume == 0:
        return 0
    return ((current_volume - average_volume) / average_volume) * 100

def calculate_price_change(current_price: float, previous_close: float) -> Dict:
    """가격 변동 계산"""
    change = current_price - previous_close
    change_percent = (change / previous_close) * 100
    return {
        'change': change,
        'change_percent': change_percent
    }

def calculate_volatility(high: float, low: float, previous_close: float) -> float:
    """변동폭 계산"""
    range_value = high - low
    return (range_value / previous_close) * 100

def normalize_scores(metrics: Dict) -> Dict:
    """점수 정규화"""
    volume_score = min(100, metrics['volume_increase'] / 3)
    price_score = min(100, metrics['price_change_percent'] / 0.1)
    volatility_score = min(100, metrics['volatility'] / 0.05)
    
    return {
        'volume_score': volume_score,
        'price_score': price_score,
        'volatility_score': volatility_score
    }

def calculate_composite_score(scores: Dict) -> float:
    """복합 점수 계산"""
    weights = {
        'volume': 0.40,
        'price': 0.35,
        'volatility': 0.25
    }
    
    return (
        scores['volume_score'] * weights['volume'] +
        scores['price_score'] * weights['price'] +
        scores['volatility_score'] * weights['volatility']
    )

def process_stocks(stock_data_list: List[Dict]) -> List[Dict]:
    """전체 종목 처리 및 순위 산정"""
    results = []
    
    for stock in stock_data_list:
        # 지표 계산
        volume_increase = calculate_volume_increase(
            stock['volume'],
            stock['average_volume']
        )
        
        price_change = calculate_price_change(
            stock['current_price'],
            stock['previous_close']
        )
        
        volatility = calculate_volatility(
            stock['high'],
            stock['low'],
            stock['previous_close']
        )
        
        metrics = {
            'symbol': stock['symbol'],
            'volume_increase': volume_increase,
            'price_change_percent': price_change['change_percent'],
            'volatility': volatility
        }
        
        # 점수 정규화
        normalized = normalize_scores(metrics)
        
        # 복합 점수 계산
        composite_score = calculate_composite_score(normalized)
        
        results.append({
            'symbol': stock['symbol'],
            'composite_score': round(composite_score, 2),
            'metrics': metrics
        })
    
    # 복합 점수 기준 정렬
    results.sort(key=lambda x: x['composite_score'], reverse=True)
    
    # 순위 부여
    for i, result in enumerate(results):
        result['rank'] = i + 1
    
    return results

def main():
    """메인 실행 함수"""
    # 주가 데이터 수집
    stock_data = collect_stock_data()
    
    # 처리 및 순위 산정
    ranked_stocks = process_stocks(stock_data)
    
    # TOP 3 선정
    top_3 = ranked_stocks[:3]
    
    print(f"TOP 3 화제 종목 ({datetime.now().strftime('%Y-%m-%d')}):")
    for stock in top_3:
        print(f"{stock['rank']}위: {stock['symbol']} (점수: {stock['composite_score']})")
    
    return top_3

if __name__ == "__main__":
    main()
```

---

## 6. 데이터 저장 구조

### 6.1 데이터베이스 스키마 (예시)
```sql
-- 종목 기본 정보 테이블
CREATE TABLE stocks (
    symbol VARCHAR(10) PRIMARY KEY,
    name VARCHAR(100) NOT NULL,
    sector VARCHAR(50),
    industry VARCHAR(50),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    updated_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP ON UPDATE CURRENT_TIMESTAMP
);

-- 일일 종목 점수 테이블
CREATE TABLE daily_stock_scores (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    symbol VARCHAR(10) NOT NULL,
    date DATE NOT NULL,
    composite_score DECIMAL(5,2) NOT NULL,
    rank INT NOT NULL,
    volume_increase DECIMAL(10,2),
    price_change_percent DECIMAL(10,2),
    volatility DECIMAL(10,2),
    created_at TIMESTAMP DEFAULT CURRENT_TIMESTAMP,
    FOREIGN KEY (symbol) REFERENCES stocks(symbol),
    UNIQUE KEY unique_stock_date (symbol, date)
);

-- 화제 종목 선정 이력 테이블
CREATE TABLE trending_stocks (
    id BIGINT AUTO_INCREMENT PRIMARY KEY,
    symbol VARCHAR(10) NOT NULL,
    date DATE NOT NULL,
    rank INT NOT NULL,
    composite_score DECIMAL(5,2) NOT NULL,
    selected_at TIMESTAMP NOT NULL,
    FOREIGN KEY (symbol) REFERENCES stocks(symbol),
    INDEX idx_date_rank (date, rank)
);
```

---

## 7. 실행 계획

### 7.1 수집 스케줄
- **실시간 수집**: 매 1분마다 주가 데이터 갱신
- **일일 집계**: 매일 장 마감 후 (오후 4시) 최종 순위 산정
- **브리핑 생성**: 매일 아침 7시 브리핑 생성

### 7.2 Cron 설정 예시
```bash
# 매일 오후 4시 (장 마감 후) 순위 산정
0 16 * * 1-5 /usr/bin/node /path/to/scripts/dailyStockRanking.js

# 매일 아침 7시 브리핑 생성
0 7 * * * /usr/bin/node /path/to/scripts/generateBriefing.js
```

---

## 8. 에러 처리 및 모니터링

### 8.1 에러 처리
- API 호출 실패 시 재시도 (최대 3회)
- 데이터 누락 시 이전 데이터 사용
- 로깅 및 알림 시스템 구축

### 8.2 모니터링 지표
- 데이터 수집 성공률
- API 응답 시간
- 점수 계산 정확도
- 순위 변동 추이

---

## 부록

### A. 실제 API 연동 예시
현재는 목업 데이터를 사용하고 있으며, 실제 운영 시 다음 API 중 하나를 사용할 수 있습니다:
- 한국투자증권 API
- Yahoo Finance API
- Alpha Vantage API
- IEX Cloud API

### B. 참고 자료
- [서비스 기획서](./서비스-기획서.md)
- [API 명세서](./API-명세서.md)

---

**문서 버전 관리**
- v1.0 (2025-12-11): 초안 작성

