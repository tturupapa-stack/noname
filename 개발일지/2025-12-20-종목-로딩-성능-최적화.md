# 종목 로딩 성능 최적화

## 날짜
2025-12-20

## 개요
사용자가 종목 로딩이 오래 걸린다고 보고하여 성능 분석 및 최적화를 수행했습니다.

## 문제 분석

### 발견된 성능 병목 지점

1. **Backend - 모멘텀 점수 순차 계산 (Critical)**
   - `screener_service.py`의 `_calculate_momentum_score()` 메서드가 각 종목마다 개별적으로 Yahoo Finance API 호출
   - 30개 후보 종목에 대해 순차적으로 `Ticker().history()` 호출
   - 예상 지연: 종목당 1-3초 = 총 30-90초

2. **Backend - 불필요한 API 중복 호출**
   - `_get_stock_detail()`에서 이미 candidate에 있는 데이터를 다시 API로 조회
   - PE ratio, 52주 최고/최저가를 위해 별도 API 호출 발생

3. **Frontend - 순차적 데이터 로딩**
   - 차트 데이터를 메인 데이터 로딩 완료 후 별도로 await 호출
   - 동일 API 중복 호출 시 캐싱 없음

## 구현된 최적화

### 1. Backend 최적화 (screener_service.py)

#### 배치 병렬 처리
```python
def _calculate_momentum_scores_batch(self, symbols: List[str]) -> Dict[str, int]:
    """
    여러 종목의 모멘텀 점수를 배치로 병렬 계산
    yahooquery의 Ticker는 여러 심볼을 한 번에 처리할 수 있음
    """
    ticker = Ticker(symbols, asynchronous=True)
    hist = ticker.history(period="1mo", interval="1d")
    # MultiIndex DataFrame에서 각 종목별 데이터 추출
```

#### 인메모리 캐시 추가
```python
def __init__(self):
    self.screener = Screener()
    self._momentum_cache: Dict[str, int] = {}  # 모멘텀 점수 캐시
```

#### 불필요한 API 호출 제거
```python
def _get_stock_detail(self, candidate: Dict) -> StockDetail:
    # candidate에 이미 있는 데이터로 StockDetail 생성
    # 추가 API 호출 없이 기본 정보만 반환
    return StockDetail(
        symbol=candidate["symbol"],
        name=candidate["name"],
        price=candidate["price"],
        # ...
    )
```

### 2. Frontend 최적화

#### API 캐싱 레이어 (services/apiCache.ts)
```typescript
class ApiCache {
  private cache: Map<string, CacheEntry<unknown>> = new Map();
  private pendingRequests: Map<string, Promise<unknown>> = new Map();

  // Request Deduplication: 동일 요청 중복 방지
  async fetchWithCache<T>(
    key: string,
    fetcher: () => Promise<T>,
    ttlMs: number
  ): Promise<T> {
    // 1. 캐시 확인
    const cached = this.get<T>(key);
    if (cached !== null) return cached;

    // 2. 진행 중인 요청이 있으면 대기
    const pending = this.pendingRequests.get(key);
    if (pending) return pending as Promise<T>;

    // 3. 새 요청 시작
    const request = fetcher().then(data => {
      this.set(key, data, ttlMs);
      this.pendingRequests.delete(key);
      return data;
    });
    this.pendingRequests.set(key, request);
    return request;
  }
}
```

#### 비동기 차트 로딩 (app/page.tsx)
```typescript
// 2단계: 로딩 완료 표시 (차트는 백그라운드에서 로드)
setIsLoading(false);

// 3단계: 차트 데이터 비동기 로드 (UI 블로킹 없음)
if (adaptedTopStock) {
  fetchStockChart(adaptedTopStock.symbol, '5d')
    .then((chartRes) => {
      setChartData(adaptChartData(chartRes.data));
    })
    .catch(console.error);
}
```

### 3. 로딩 UX 개선

#### 개선된 스켈레톤 UI
- 기존 단순 `skeleton` 클래스에서 구체적인 레이아웃을 반영한 스켈레톤으로 변경
- 카드 구조, 텍스트 위치를 실제 컨텐츠와 유사하게 표현

## 예상 성능 개선 효과

| 구분 | Before | After | 개선율 |
|------|--------|-------|--------|
| 모멘텀 점수 계산 | 30-90초 (순차) | 3-5초 (배치) | ~90% |
| _get_stock_detail API | 1-2초 | 0초 (캐시 재사용) | 100% |
| 프론트엔드 캐시 히트 | N/A | 3분간 유효 | - |
| 차트 로딩 대기 | UI 블로킹 | 백그라운드 | UX 개선 |

## 수정된 파일

### Backend
- `/backend/services/screener_service.py`
  - 배치 모멘텀 점수 계산 추가
  - 인메모리 캐시 추가
  - 불필요한 API 호출 제거

### Frontend
- `/services/apiCache.ts` (신규)
  - 프론트엔드 캐싱 레이어
- `/services/api.ts`
  - 모든 API 함수에 캐싱 적용
- `/app/page.tsx`
  - 비동기 차트 로딩
  - 개선된 스켈레톤 UI

## 테스트 결과
- Backend Python import 테스트: 성공
- TypeScript 컴파일: 성공 (presentation 페이지 기존 오류 제외)

## 추가 고려사항

1. **Redis 캐시 활용**
   - 현재 L1(메모리) 캐시만 사용 중
   - Redis 설정 시 서버 재시작 시에도 캐시 유지 가능

2. **캐시 TTL 조정**
   - 시장 상황에 따라 캐시 TTL 조정 필요
   - 현재 설정: 3-5분

3. **프리로딩 개선**
   - 서버 시작 시 주요 데이터 프리로딩 활성화
   - `main.py`의 `preload_cache()` 함수 활용

## 관련 이슈
- 사용자 보고: 종목 로딩 지연 문제
